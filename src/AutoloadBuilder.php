<?hh

	class AutoloadBuilder {

	const NS = "namespace";
	const CN = "class";

	public $map = Map{};

	public function scanning($dir, $include_pattern, $exclude_pattern) {
		$namespace_length = strlen($this::NS);
		$class_length = strlen($this::CN);
		$include_files = glob($dir."/".$include_pattern);
		$exclude_files = glob($dir."/".$exclude_pattern);
		$iterator = new FileSystemIterator($dir);
		foreach ($iterator as $fileinfo) {
			$namespace = "";
			$file = $fileinfo->getFileName();
			$path = $dir."/".$file;
			if($fileinfo->isDir()) {
				scanning($path, $include_pattern, $exclude_pattern);
			}
			else {
				if(in_array($path, $include_files) && !in_array($path, $exclude_files)) {
					$spl_file = new SplFileObject($file);
					while(!$spl_file->eof()) {
						$file_string = $spl_file->fgets();
						$sub_string_namespace = strstr($file_string, $this::NS);
						//looking namespace
						if(!empty($sub_string_namespace)) {
							$sub_string_namespace = trim(substr($sub_string_namespace, $namespace_length));
							$sub_string_namespace = trim($sub_string_namespace, ";");
							$namespace = $sub_string_namespace.'\\';
							continue();
						}
						$sub_string_classname = strstr($file_string, $this::CN);
						//looking classname
						if(!empty($sub_string_classname)) {
							$replace = array("{", "}");
							$sub_string_classname = trim(substr(str_replace($replace, "", $sub_string_classname) , $class_length));
							$this->map[$namespace.$sub_string_classname] = $path;
						}
					}
				}
			}
		}
	}

	function __construct() {

		$filename_autoloader = NULL;
		$include_pattern = "*.php";
		$exclude_pattern = "";

		$header_autoloader = <<<EOL
<?hh
	// @codingStandardsIgnoreFile
	// @codeCoverageIgnoreStart
	// this is an autogenerated file - do not edit
	spl_autoload_register(
    	function($class) {
        	static $classes = null;
        	if ($classes === null) {
            	$classes = array(
EOL;
		$footer_autoloader = <<<EOL
 );
        }
        $cn = strtolower($class);
        if (isset($classes[$cn])) {
            require __DIR__ . $classes[$cn];
        }
    }
);
// @codeCoverageIgnoreEnd
EOL;
		$content = "";
		$result_str = "";
		//put header_autoloader.php into $result_str 
		$result_str .= $header_autoloader;
		$parameters = array(
			'i::' => 'include::',
			'e::'  => 'exclude::',
			'o::' => 'output::'
		);
		$options = getopt(implode('', array_keys($parameters)), $parameters);
		$pruneargv = array();
		foreach ($options as $option => $value) {
			switch ($option) {
				case 'i':
				case 'include':
					$include_pattern = $value;
					break;
				case 'e':
				case 'exclude_pattern':
					$exclude_pattern = $value;
					break;
				case 'o':
				case 'output':
					$filename_autoloader = $value;
					break;
				default:
					echo "Unknown option: $option\n";
					break;
			}
		}
		foreach ($options as $option => $value) {
  			foreach ($argv as $key => $chunk) {
    			$regex = '/^'. (isset($option[1]) ? '--' : '-') . $option . '/';
    			if ($chunk == $value && $argv[$key-1][0] == '-' || preg_match($regex, $chunk)) {
      				array_push($pruneargv, $key);
    			}
  			}
		}

		while ($key = array_pop($pruneargv)) { 
			unset($argv[$key]);
		}

		for($i = 1; $i < count($argv); $i++) {
			$this->scanning($argv[$i], $include_pattern, $exclude_pattern);
		}
		foreach ($this->map as $className => $fileName) {
			$content .= "'".$className."'=>'/".$fileName.".php'\n";
		}
		$result_str .= $content;
		//put footer_autoloader.php into hackab_autoloader.php
		$result_str .= $footer_autoloader;
		if(is_null($filename_autoloader)) {
			file_put_contents($filename_autoloader, $result_str);
		}
		else {
			echo "$result_str\n";
		}
	}
}